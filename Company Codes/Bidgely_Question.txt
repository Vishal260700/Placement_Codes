# Count number of times F(0) and F(1) is called while calculating F(n)
# Recursive        
ans = [0]
def solve(n):
    if(n == 0):
        ans[0] += 1
        return 0
    if(n == 1):
        ans[0] += 1
        return 0
    return solve(n-1) + solve(n-2)
solve(N)
print(ans[0])


# DP
DP = [-1 for x in range(0, N + 1)]

def solve(n):
    if(n == 0):
        return 1
    if(n == 1):
        return 1
    
    if(DP[n] == -1):
        DP[n] = solve(n-2) + solve(n-1)
    
    return DP[n]

solve(N)

print(DP[-1])

# Check if 2 strings have a common substring or not

# We can do by longest common subsequence and longest common substring but runtime error in some testcases

# But easy peasy by hashing
Hash1 = [0 for x in range(0, 26)]
Hash2 = [0 for x in range(0, 26)]

for char in str1:
    Hash1[ord(char) - 97] += 1

for char in str2:
    Hash2[ord(char) - 97] += 1

for i in range(26):
    if(Hash1[i] != 0 and Hash2[i] != 0):
        return 'YES'

return 'NO'

## Given an array of size n, find the xor of all i consecutive elements where i = 1,2,3,......,n.
Input : [1,2,3]
Output : 2
Explanation : 1^2^3^(1^2)^(2^3)^(1^2^3) = 2
Input : [1,2,3,4]
Output : 0
Explanation : 1^2^3^4^(1^2)^(2^3)^(3^4)^(1^2^3)^(2^3^4)^(1^2^3^4) = 0 

Arr = list(map(int, input().strip().split()))

if(len(Arr) % 2 == 0):
    # even
    print(0)
else:
    # Odd - XOR of odd placed ones
    res = Arr[0]
    for i in range(1, len(Arr)):
        if((i+1) % 2 != 0):
            res = res^Arr[i]
    print(res)

# Given N numbers ,you are allowed to either pair a number with  another number or leave it alone. 
# you have to Maximize sum(output).
# sum is formed by adding all unpaired numbers and adding product of each pair. 
# Ex: n1 ,n2,n3,n4 . If you choose to pair n1,n2 & leave alone n3,n4
# then sum =n1*n2 +n3+n4; 

Arr = list(map(int, input().strip().split())) # there can be negative numbers too
Arr.sort() # definetly helps

if(len(Arr) == 1):
    print(Arr[0])
elif(len(Arr) == 0):
    print(-1)
else:
    ans = 0
    i = len(Arr) - 1
    
    while(i >= 0):
        if(i == 0):
            ans += Arr[i]
            i -= 1
        else:
            p1 = Arr[i]
            p2 = Arr[i-1]
            
            if(p1 > 0 and p2 > 0):
                ans = ans + max(p1*p2, p1 + p2)
                i -= 2
            elif(p1 < 0 and p2 < 0):
                ans = ans + max(p1*p2, p1 + p2)
                i -= 2
            else:
                ans += p1
                i -= 1
    
    print(ans)


# Simpligy Directory Path

# Lightweight python slip function helps
dirs = A.split('/')
result = []
for c in dirs:
    if c == '' or c == '.': continue
    elif c == '..':
        if len(result)>0: result.pop()
    else:
        result.append(c)
return '/'+'/'.join(result)

# My solution -- working but kahi choti dikkat aa rahi but concept correct -- thinking process correct   
stack = []

tempDir = ""
for i in range(0, len(A)):
    if(A[i] == '/'):
        if(tempDir == '..'):
            if(stack):
                stack.pop()
        elif(tempDir == '.' or tempDir == ''):
            # Do nothing
            tempDir = ""
        else:
            stack.append(tempDir)
        # Restart
        tempDir = ""
    else:
        tempDir += A[i]

if(tempDir == '..'):
    if(stack):
        stack.pop()

res = ""

for char in stack:
    res += '/'
    res += char
    
return (res) if(res) else '/'